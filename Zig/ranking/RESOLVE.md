## (2021.10.12) 프로그래머스 - 순위

> 그래프
> 출처: [링크](https://programmers.co.kr/learn/courses/30/lessons/49191?language=javascript)

그래프 문제 중에 가장 복잡한 것 같은 플로이드-와샬 알고리즘을 이용한 문제라고 한다. 플로이드-와샬 알고리즘은 모든 노드로부터 다른 노드까지의 최단 거리를 저장하는 방법이다. 

3중 for문을 이용하여 각 정점마다 다른 정점까지의 최단 거리를 모든 정점에 대해 구하기 때문에 O(N^3) 시간이 소요된다. (느리다는 얘기다.) 그러나 양과 음의 모든 가중치에 대해 계산이 가능하다는 특징이 있다.

예를 들어 a, b, c라는 경로가 있다고 가정해 보자.
- a ➡️ c로 가는 경로의 비용: 7
- a ➡️ b로 가는 경로의 비용: 2
- b ➡️ c로 가는 경로의 비용: 3
이라면,
a ➡️ c로 가는 비용을 2 + 3 = 5로 갱신시키는 방식이다.

이 논리를 이용하여 문제를 풀 수 있다.
a가 b를 이겼고, b가 c를 이겼으면 a가 c를 이겼다고 표시한다.

우선, 2차원 배열 `graph`를 만들어 모든 요소를 `0`으로 초기화시킨 후 `results` 배열을 돌며 이긴 경우엔 `1`을, 진 경우에는 `-1`을 표시한다.

이후 3중 for문을 돌면서 플로이드 와샬 알고리즘의 기본을 구현한다. a가 b를 이겼고, b가 c를 이겼으면 a가 c를 이겼다는 의미로 `1`을 표시한다. 진 경우에는 동일한 방식으로 `-1`을 표시한다.

모두 표시가 끝나면 `graph`의 각 row에 있는 `0`과 `1`, `-1`의 개수를 센다. `1`과 `-1`의 경우 승패가 명확함을, `0`의 경우 `row === col`이거나(즉, 자기 자신) 승패가 불분명함을 의미한다. 따라서 `graph`의 전체 row 중 `0`이 1개인 row의 개수를 리턴하면 된다. (실제로는 선수 번호에 맞추어 인덱싱을 1부터 했으므로, 0번째 row과 col에는 모두 0이 들어가 있다. 이를 계산에서 제외시키기 위해 `slice` 메소드를 사용했다.)

왜 테케 절반은 실패하는지 모르겠다 🤷‍ 
해당 케이스 번호들은 질문란에서도 의문으로 남은 듯 하다. 심지어 출처 코드는 다 통과했다는데 (우테코 3기 백엔드 크루인 것 같다.) 그대로 언어만 바꿔서 돌려봐도 똑같은 테케들만 실패한다! 고로 그냥 넘어간다.

**Ref** <https://mungto.tistory.com/58>  