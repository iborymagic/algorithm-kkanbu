## (2021.12.14) 단속카메라

> 출처: https://programmers.co.kr/learn/courses/30/lessons/42884

예전에 풀었던 문제인데, 그리디 알고리즘(greedy algorithm) 복습 겸 한번 더 풀어보기!

우선 카메라가 최소 1대는 있어야 하므로 `answer`의 초기값을 `1`로 설정하고, 가장 최적의 답을 먼저 찾아가는 그리디 알고리즘답게 `routes`의 원소들을 진입 지점 순서대로 정렬해준다.
```jsx
let answer = 1;
routes.sort((a, b) => a[0] - b[0]);
```

첫 번째 경로, 즉 진입점이 가장 빠른 경로의 진출점을 찾는다.
```jsx
let temp = routes[0][1];
```

`routes` 배열을 돌며, (B)다음 경로의 진출점(`routes[i][1]`)이 (A)`temp`보다 빠르다면(작다면) `temp` 경로가 다음 경로를 포함하고 있다는 뜻이므로 카메라 설치를 보류하고, `temp` 값을 더 작은 다음 경로의 진출점으로 갱신해준다.
```
진입A - 진입B - 진출B - 진출A
```
```jsx
if (temp > routes[i][1]) {
  temp = routes[i][1];
}
```

반면 (B)다음 경로의 진입점(`routes[i][0]`)이 (A)`temp`보다 늦다면(크다면) 아래와 같은 구조가 된다.
```
진입A - 진출A - 진입B - 진출B
```

`진출A`와 `진입B` 사이 어딘가에 카메라를 설치할 필요가 있으므로 `answer`에 추가해주고, `temp` 값을 다음 경로의 진출점인 `routes[i][1]`로 갱신해준다.

```jsx
if (temp < routes[i][0]) {
  answer++;
  temp = routes[i][1];
}
```

🤔 다음 경로들은 신경쓰지 않아도 괜찮을까?
1. (B)다음 경로의 진출점이 (A)`temp`보다 크거나 같은 경우
```jsx
if (temp <= routes[i][1]) { /* ... */ }
```
```
진입A - (진입B) - 진출A - (진입B) - 진출B
```
이 경우 B의 진입점을 확실히 알 수 없다. 2가지 후보가 나온다.
B의 진입점이 첫 번째 위치라면 A와 B가 섞여서 나오므로 상관없다. B의 진입점이 두 번째 위치라 해도 `if (temp < routes[i][0])`에서 걸러지게 되므로 문제없다.

2. (B)다음 경로의 진입점이 (A)`temp`보다 작거나 같은 경우
```jsx
if (temp >= routes[i][0]) { /* ... */ }
```
```
진입A - 진입B - 진출A - 진출B
```
A와 B가 섞여서 나오므로 상관없다!

요로코롬 코드를 작성해 보았다. 인덱스가 자꾸 왔다갔다해서 엄청 헷갈린다. 출처는 지난 날의 나 자신. 


