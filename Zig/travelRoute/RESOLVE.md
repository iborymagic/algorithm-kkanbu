## (2021.10.07) 프로그래머스 - 여행 경로

> 깊이/너비 우선 탐색(DFS/BFS)
> 출처: [링크](https://programmers.co.kr/learn/courses/30/lessons/43164?language=javascript)

DFS(Depth-First-Search)를 사용했다. 

JavaScript가 아주 가끔 똑똑하다고 느낄 때가 있는데, 바로 오늘이다. ['ICN', 'SFO']와 같이 두 개의 요소를 갖는 배열들로 구성된 배열의 `sort`를 자동으로 해준다. 첫 번째 요소들로 오름차순 정렬이 끝나면, 두 번째 요소들로 오름차순 정렬을 해주는 것이다.

문제 조건에 `만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.`라고 되어있지만, 무조건 알파벳 순으로만 다음 여행지를 찾아가는 것은 옳지 않다. 결과적으로 모든 항공권을 다 소비해야 하는데, 알파벳 순으로만 찾아가다보면 중간에 연결이 끊길 수 있기 때문이다.

문제의 인자로 들어온 `tickets` 배열, 현재 위치를 가리키는 `from`, 총 방문해야 하는 공항들의 방문 여부를 담은 배열 `visited`를 활용하여 dfs 함수를 구현했다. 

이때, 총 방문해야 하는 공항의 개수는 두 공항을 연결한 항공권 정보들이 담겨있는 `tickets`의 length보다 1이 더 크다. 첫 번째 테스트케이스의 예시를 생각해 보았을 때, 

> tickets: \[["ICN", "JFK"], ["HND", "IAD"], ["JFK", "HND"]]

ICN ➡️ JFK ➡️ HND ➡️ IAD로 가는 과정에서 가장 첫 출발지와 가장 마지막 도착지는 한번 더 카운트되기 때문이다.

따라서 `visited` 배열의 크기는 `tickets.length + 1`이 올바르겠지만, 마지막으로 방문하게 될 공항은 따로 `visited` 배열에 담을 필요 없이 그대로 리턴하면 되므로 `visited` 배열의 크기를 `tickets.length`와 동일하게 설정해 주었다.

```jsx
const visited = Array(tickets.length).fill(false);
```

dfs 함수의 반환값은 현재 진행하고 있는 여행경로로 모든 항공권을 다 쓸 수 있는지 여부를 나타내는 boolean 값이다. 구현부에서는, 모든 공항이 방문되었을 때 빠르게 리턴할 수 있도록 base case를 심어주었다.

```jsx
if (visited.every((visit) => visit)) return true;
```

그 후 `tickets` 배열을 순회하며 현재 있는 위치(가장 첫 시작점은 'ICN')를 visit로 체크해주고 (`visited[i] = true;`), 현재 항공권의 목적지를 다음 여행 경로로 담아준다. (`answer.push(tickets[i][1]);`)

현재 목적지는 다음 경로의 출발지가 되므로, `tickets[i][1]`을 출발점으로 하는 dfs를 재귀적으로 호출한다. 이때 이 경로가 가능한 경로라면 (`pos === true`) 계속 진행하지만, 재귀적으로 호출한 dfs 함수 바디 안에서 for문을 다 돌 때까지 새로운 경로를 찾지 못한다면 false를 리턴한다. 이때 방금까지 지나왔던 경로를 다시 제거하고(`visited[i] = false`) 새로운 경로의 탐색을 계속한다. 여기서 `tickets[i][0] === from`이라는 조건문은 계속 유효하므로, 만약 ICN ➡️ SFO로 가는 경로가 유효하지 않다면 출발지 ICN는 그대로 유지한 채 ICN ➡️ ATL로 가는 경로를 탐색할 것이다.

처음에는 경로를 끝까지 탐색하기 위해 dfs를 중간에 중단시키는 로직을 생각하지 못했다. 그래서 항공권을 전부 사용하지 못한 채 경로가 끝나버려 일부 테스트케이스에서 통과하지 못했다. 문제의 조건을 잘 파악하여 우선순위를 이해하고 코드의 로직을 작성해나가도록 하자!


**Ref** <https://nanyoungkim.tistory.com/93> 